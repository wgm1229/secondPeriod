## day20201224

### 17.0 以后被弃用的生命周期函数

componentWillMount
componentWillreceiveProps
componentWillUnMount

### 组件传参

父传子：属性
子传父:方法
redux:状态管理

## admin路由
1.引入react-router-dom和需要的子组件
```
import { Redirect,Switch,Route} from 'react-router-dom';

import Home from './Home';
...
```
2.设置路由
```
<Content>
  <Switch>
      <Route path="/home" component={Home} />
      <Route path="/category" component={Category} />
      <Route path="/product" component={Product} />
      <Route path="/role" component={Role} />
      <Route path="/user" component={User} />
      <Route path="/charts/bar" component={Bar} />
      <Route path="/charts/line" component={Line} />
      <Route path="/charts/pie" component={Pie} />
      <Route path="/order" component={Order} />

      <Redirect to="/home" /> //如果没有匹配到以上的路径，就重定位到/home
  </Switch>
</Content>
```
## LeftNav动态生成导航
1.引入menuList数据包
```
import menuList from '../../config/menuConfig';
```
2.定义生成导航方法
```
getMenuList = (menuList)=>{
  const path = this.props.location.pathname;
  return menuList.map((item) => {
    if (!item.children) {
      //如果不存在子菜单，说明只有一级菜单
      return (
        <Menu.Item key={item.key}>
          <Link to={item.key}>
            <Icon type={item.icon} />
            <span>{item.title}</span>
          </Link>
        </Menu.Item>
      );
    } else {
      //如果有children，说明是有子菜单的
      const cItem = item.children.find((cItem) => cItem.key === path);
      if (cItem) {
        this.openKey = item.key;
      }
      return (
        <SubMenu
          key={item.key}
          title={
            <span>
              <Icon type={item.icon} />
              <span>{item.title}</span>
            </span>
          }
        >
          {this.getMenuList(item.children)}
        </SubMenu>
      );
    }
  });
};
```
3.在componentWillMount中调用生成导航函数getMenuList()
```
// 这个生命周期函数是在render之前执行的
componentWillMount() {
  this.getNodes = this.getMenuList(menuList);
}
```
4.在渲染页面中调用getNodes
```
const getNodes = this.getNodes;

<Menu
  selectedKeys={[path]}
  defaultOpenKeys={[openKey]}
  mode="inline"
  theme="dark"
>
  {getNodes}
</Menu>
```
5.通过this.props获取的当前path来绑定当前路径对应的导航项选中和子导航展开
```
const path = this.props.location.pathname;
const openKey = this.openKey;
<Menu
  selectedKeys={[path]}
  defaultOpenKeys={[openKey]}
  mode="inline"
  theme="dark"
>
```
### leftnav 不是路由组件，所以如果想使用路由功能的话，需要 withRouter 对其进行包装，将其转换成路由组件，方可使用
```
import { withRouter,Link } from 'react-router-dom';

export default withRouter(LeftNav)
```
### 左侧菜单需要和路由配置一一对应,组要使用 link 标签使其点击进行跳转
```
<Link to={item.key}>
```
### 路由对象有三大属性
this.props

history
location
match

### 在生命周期里面 componentDidMount 是在 render()之后执行的,componentWillMount 是在 render()之前执行的,而且他们都是执行一次

### 重点难点

递归获取一级菜单和二级菜单(为什么要递归),因为牵涉到二级菜单，我们不能直接把菜单写死在页面上，这样的话程序没有扩展性，
根据当前的 pathname 使对应的菜单选中，如果当前 pathname 有父亲的话，需要让父亲折叠状态变为打开状态，其余二级菜单合并起来
我在动态获取（遍历）菜单的时候，如果在 render 里面调用的话，那么我是拿不到 openKey,所以说我没有在 render 里面调用，而是在 conponentWillMount 里面执行获取动态菜单，从而在生命周期 conponentWillMount 阶段获取 this.openKey,因为 componentWillMount 是在 render 函数执行之前执行的,我也没有在 componentDidMount 里面调用,因为 componentDidMount 是在 render 函数之后执行的,如果在这个阶段(componentDidMount)执行,那么你也就错过了获取 openkey 的时机,就是说折叠菜单是再也打不开的,所以说，要理解生命周期的正确使用方式，从而可以解决问题,这些东西实际上是牵涉执行流程的。
对于 api 文档，大家要自己使用一下
