## github后端接口代码更新
1. 在QQMusicApi目录下，获取最新服务端代码
```
git pull
```
2. 重新启动接口服务
```
npm run start
```
## 获取专辑图片
```
`https://y.gtimg.cn/music/photo_new/T002R300x300M000${专辑mid}.jpg`
```

## 优化歌词跟进度条同步
> Lyric.vue组件 的 computed
```
isPlay(newPlay,oldPlay){ //检测音乐的播放状态，同步切换歌词播放状态
  console.log('歌词播放状态',newPlay);
  if(!this.lrcObj){return false}
  // this.lrcObj.togglePlay()  //切换歌词的播放状态
  if(newPlay){
    this.lrcObj.play(this.seektime*1000) //从新指定的时间点开始播放歌词
  }else{
    this.lrcObj.stop()  //停止歌词的切换
  }
}
```

## 控制歌曲播放暂停
+ 控制vuex中的isPlay动态变化
+ watch监听到isPlay的变化后，相应改变歌曲的播放状态
+ 通过isPlay控制按钮图标的切换

Player组件
绑定handlePlay事件
```
<i class="iconfont icon-15 sm" :class="`icon-${isPlay?15:24}`" @click="handlePlay"></i>
```
```
handlePlay() {//控制歌曲播放暂停
      let bool = !this.isPlay;
      this.$store.commit("player/isPlayMut", bool);
    },
```

## 歌曲切换
Player组件
绑定prevSong、nextSong事件
```
<!-- 上一曲 -->
<i class="iconfont icon-14 sm" @click="prevSong"></i>
<!-- 下一曲 -->
<i class="iconfont icon-12 sm" @click="nextSong"></i>
```
```
prevSong() {//上一曲
  this.$store.commit("player/currentMut", this.currentSong - 1);//切换歌曲数据包
  let { mid } = this.song;
  this.getSongUrlFn(mid);//重新获取新的歌曲播放路径
},
nextSong() {//下一曲
  this.$store.commit("player/currentMut", this.currentSong + 1);//切换歌曲数据包
  let { mid } = this.song;
  this.getSongUrlFn(mid);//重新获取新的歌曲播放路径
},
```

## 歌词切换
+ 歌曲是怎么切换的？  状态机中的下标控制的
+ 在Lyric.vue中监听正在播放的歌曲的下标变化，从而获取新的歌词，并触发播放
Lyric组件
watch监听currentSong歌曲下标的变化
```
currentSong(){ //监听歌曲下标的变化
  console.log('歌词组件监听下标',this.song);
  
  let {mid} = this.song;
  this.getLrcById(mid) //重新加载新歌曲对应的歌词
},
```
## 播放模式
+ 播放模式的点击提示交互，在vuex中定义合适的状态数据包
+ 不同的播放模式下，切换下一曲的目标曲目不一样
  - 单曲循环，直接重新播放当前歌曲
  - 顺序播放，调用nextSong
  - 随机播放，从歌曲列表中，随机抽出一首歌曲播放
1.Store状态机player.js
```
state:(){
  return {
    loop:0,   //播放模式 0单曲  1顺序  2随机
    loopData:[
      { title: '单曲模式', icon: 'icon-16' },
      { title: '顺序模式', icon: 'icon-17' },
      { title:'随机模式', icon:'icon-19'},
    ]
  }
},
getters:{
  loopObj(state){  //根据模式序号，提取对应数据包
    return state.loopData[state.loop]
  }
},
mutations:{    
  changeLoop(state){ //修改播放模式
    if(state.loop==2){
      state.loop=0;
    }else{
      state.loop++
    }
}
```
2.Player组件
2.1样式通过状态机中的数据绑定
```
<!-- 控制播放模式 
  单曲循环  icon-16
  顺序播放  icon-17
  随机播放  icon-19
-->
<i class="iconfont sm" :class="loopObj.icon" @click="changeLoopFn"></i>
```
2.2控制播放结束后的下一曲,绑定ended事件,ended为audio自带的事件类型,歌曲播放结束后触发
```
<!-- 播放器 -->
<audio :src="songurl" @canplay="canplay" @timeupdate="timeupdate" @ended="ended" ref="audio"></audio>
```
```
ended() {//当前歌曲播放完毕后
  console.log("播放结束");
  this.changeIsPlay(false);
  let mid;
  switch (this.loop) {
    case 0:
      console.log("单曲播放");
      this.changeIsPlay(true);

      this.single = !this.single//改变单曲循环的布尔值
      mid = this.song.mid;
      this.getSongUrlFn(mid);//重新获取新的歌曲播放路径
      this.$refs.audio.play();
      break;
    case 1:
      this.nextSong();
      break;
    case 2:
      let num = parseInt(Math.random() * 19);//根据歌曲列表的总条数，生成一个范围内的随机数
      this.changeCurrent(num);//切换歌曲数据包
      mid = this.song.mid;
      this.getSongUrlFn(mid);//重新获取新的歌曲播放路径
      break;
    default:
      break;
  }
```
2.3单曲循环模式歌词不更新:
添加single布尔值,通过在PLayer中改变布尔值
=>传递到Lyric组件中
=>监听single的变化
=>single发生改变就重新获取歌词数据包

## vuex的辅助函数的使用
  + mapMutations
  + mapGetters
  + mapState
1.引用vuex辅助函数
2.放在computed中:
mapState:
数据名:(state) => state.模块名.State的数据名

mapGetters:
数据名: "模块名/Getters的数据名"

3.放在methods中:
mapMutations:
函数名称:"模块名/Mutations名"  (自定义函数名称)
引用函数:
函数名称(参数)
```
import { mapMutations, mapState, mapGetters } from "vuex";
```
```
computed:{
  ...mapState({
      loop: (state) => state.player.loop,
    }),
  ...mapGetters({
    loopObj: "player/loopObj",
  }),
}
```
```
methods: {
  ...mapMutations({
    changeLoopFn: "player/loopMut",
    changeIsPlay: "player/isPlayMut",
    changeCurrent: "player/currentMut",
  }),
}
## 任务
  + 歌曲切换方法的封装 
    - 上一曲
    - 下一曲
    - 播放完毕的切换
