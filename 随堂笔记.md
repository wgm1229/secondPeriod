## 发起异步请求的方式
1. 原生JS的Ajax请求封装
```
var xhr = new XMLHttpRequest()   //new ActiveXObject('')做兼容
xhr.open('get')
xhr.send()
xhr.onreadystatechange = ()=>{
  if(xhr.readyState==4&&xhr.status==200){
    console.log(xhr.responseText)
  }
}
```

2. JQuery的Ajax方法使用
```
$.ajax({
  url:'',
  method:'',
  dataType:'json',
  data:{},
  success:()=>{},
  error:()=>{}
})
```

3. fetch方法（原生js提供的）
```
fetch(url).then(res=>{
  return res.json()
}).catch(res=>{
  console.log(res)
})
```

4. axios模块
  + axios({url,method,headers,data})
  + axios.get(url).then()
  + axios.post(url,data).then()
  + const instance = axios.create({
    baseURL:'',
    headers:{}
  })
  + 请求拦截器，在发起请求之前统一作出拦截判断
  + 响应拦截器，在后端下发数据后，统一处理响应的提示等操作
  ```
  res.code || res.status  判断并作出相对应的用户提示
  ```

## 跨域问题及其解决方案

1. 什么是跨域？如何产生跨域？CORS浏览器同源策略？

2. jsonp跨域解决方案
  + jsonp本身发起的并不是ajax请求，不会触发浏览器CORS
  + 通过script标签请求对应资源接口
  + 只有jsonp专属的接口，才能通过这种方式访问  callback({code:0,data:{}})
  + 服务端的callback是固定的 或 可以由前端自定义的

3. 通过本地代理实现跨域访问
  + 本地浏览器----远程服务器   不同源则跨域
  + 本地浏览器---本地服务器---远程服务器
  + vue.config.js中配置代理
  + vue项目打包后，本地代理会失效

4. 搭建代理服务器
  + Nodejs、Express搭建自己的服务器
  + http-proxy-middleware   npm中间件模块来实现代理配置
  + cors    npm模块，配置自己的nodejs，允许跨域访问
  + 本地浏览器----Nodejs服务器（允许跨域）--- 远程服务器

5. 终极解决方案 【优先使用】
  + 喊后端工程师允许跨域访问

6. 后端允许前端跨域访问的原理？
  + 配置一个响应头
  ```
  access-control-allow-methods: GET, POST
  access-control-allow-origin: *
  ```

## JS的模块化方式

1. 以前的一些模块化方案（第三方的解决方案）
  + require.js
  + sea.js

2. CommonJS规范定义的模块化
  + module.exports  导出数据或方法
  + require('模块相对路径')   引入模块数据或方法

3. ES6模块化
  + export const fn = ()=>{}   可以在同一个模块中导出多个独立的方法
  + import {fn} from '模块相对路径' 
  + export default fn = ()=>{}   统一导出一个模块整体
  + import fn from '模块相对路径' 

## Vue技术栈
> 单页面应用 SPA
1. 常用指令
  + v-html  富文本数据
  + v-if v-show 条件渲染
  + v-model
  + v-for   :key=""   虚拟DOM与Diff算法
  + v-on:click   @click
  + v-bind:class  :class

2. 自定义指令
  + 全局指令   Vue.directive()
  + 局部指令   directives:{}

3. Vue实例对象、Vue组件的常用配置
  + 两者都可以用的
    - computed   察觉data变化，返回新数据包
    - watch      察觉data变化，作出响应 （深监听、浅监听）
    - methods
    - components
    - created 等生命周期函数(能够阐述生命周期流程)
  + Vue实例特有的
    - data 对象
    - el
  + Vue组件特有的
    - data  必须是函数（能够解释为什么？）为了使每一个组件的状态相互不干扰，不形成数据污染，data必须是一个工厂函数。
    - props:['参数名']  从组件外部传递数据给组件内部
    - props:{'参数名':{type,required,validator}}   约束参数的格式

4. 项目组件封装
> 组件粒度
> 组件三要素：结构、样式、功能
> 开放封闭原则？
  + props
  + slot 插槽
  + $emit

5. 组件通信方式
  + props 父子通信
  + $emit  子父通信
  + bus事件总线   非父子关系的组件通信
  + $refs获取DOM及组件实例   顺便能实现组件通信
  + vuex 集中管理跨组件共享的数据 

6. vuex的使用
  + 基本使用流程
  + 通过模块化的方式，使用vuex，拓展性更好 【推荐】
  + 核心API
    - state
    - getters
    - mutations
    - actions  在状态机中发起异步请求的
    - modules  模块化
  + 在组件中操作状态机的方法 【模块化的操作】
    - this.$store.state.模块名.数据名
    - this.$store.getters['模块名/数据名']
    - this.$store.commit['模块名/mutation名']
    - this.$store.dispatch['模块名/action名']
  + 辅助函数
    - mapState
    - mapGetters
    - mapMutations
    - mapActions

7. vue-router路由管理
  + 基本使用流程
    - 安装、引入配置、注入、使用
  + 动态路由（路由传参）
    - 设置形参、传递实参、提取使用
    - this.$route.params
  + 编程式导航
    - this.$router.push('路径')
    - this.$router.push({
      name:'路由名称',
      params:{}
    })
  + 路由嵌套，理论上可以嵌套n层
    - 创建组件、调整路由、设置router-view
    - {
      path:'',
      component:Product,
      children:[]
    }
  + 路由守卫、路由拦截、导航守卫
    - router.beforeEach  在用户进入某个路由前，作出权限判断
    - beforeRouteUpdate  已经在/detail/123路由下了，想进入/detial/456
  
  + 路由模式
    - hash  哈希模式，监听hash值的变化，渲染对应的组件
    - history 模式 

8. Vue管理系统
  + 组件库从零搭建  ElementUI、iview、Vant（移动端）
  + 社区开源的管理系统  【开发效率更高一些】
  [vue-element-admin](https://panjiachen.github.io/vue-element-admin-site/zh/)

9. Nuxt.js框架  【了解】
[官网](https://zh.nuxtjs.org/)
> 用vue语法来做需要服务端渲染的项目
+ vue项目创建   vue create my-app
  - 自己手动配置路由
+ nuxt项目创建  yarn create nuxt-app <project-name>
  - 约定大于配置  按照pages的目录结构，自动生成路由  

10. @vue/cli脚手架
  + 安装使用
  + vue.config.js自定义配置
  + devServer.proxy代理
  + publicPath    配置打包后的资源引用路径
    - npm run serve 本地运行
    - npm run build 打包项目
  + 熟悉项目打包上线的流程 【待补充】

11. 提问vue技术栈问题的套路？
  + 从使用的角度提问？            某个技术点有使用过吗？咋用的？
  + 从具体某个API的使用经验？      vuex的actions方法具体在哪个项目功能中使用并实现了什么功能？
  + vuex的实现原理是否有了解过？  【灵魂之问】
    [参考文章](https://juejin.cn/post/6844904081119510536)

## ES6相关
[ES6标准入门](https://es6.ruanyifeng.com/)
1. 常用的ES6方法？
+ 解构赋值/{}=对象
+ 扩展运算符(...)展开/合并
+ Symbol()独一无二的值,防止属性名冲突/新的原始数据类型
+ mixin()合并多个对象的属性/你使用了一个他人提供的对象，但又想为这个对象添加新的方法
+ Map()键值对
+ Set()成员值都是唯一的，没有重复的值
+ Promise对象 进行异步操作/new Promise(function(resolve, reject){})

2. 正确的回答姿势
+ 箭头函数的各种使用姿势
  ```
  let fn = a => a*2
  let fn = (a,b) => {
    return a+2
  }
  let fn = (name,score)=>({name,score})
  ```
+ 数组的方法拓展  includes /Array.of方法用于将一组值，转换为数组。
+ 对象的方法拓展  
  var obj = {
    属性名:属性值,
    函数名:function(){}
  }
+ 函数的拓展/形参的默认值
+ Promise对象 【口喷Promise】
  - 如何使用Promise对象?   new Promise((resolve,reject)=>{})
  - 项目什么场景中用Promise封装过什么方法？  axios的封装原理
    [Promise实现axios功能封装](https://juejin.cn/post/6856706569263677447)
  - 能不能手写一个Promise构造函数？
  > 假设JS没有提供Promise构造函数，你能不能自己搞一个？
    [Promise原理](https://juejin.cn/post/6918719482575880200)
+ Generator函数/异步编程解决方案
+ async await  将异步请求，处理为同步方式
  - 好处，提高代码可读性
  - 弊端，阻塞代码运行
+ Class类相关
  - super 的使用
  - 类的继承
  - this指向的问题



