## 手写react路由
> Link 与 Route组件
1. 回顾真实react-router使用流程
+ Route组件的使用
```
<Route path="/home" component={Home}/>
<Route path="/product" component={Product}/>
```
+ Link组件
```
<Link to="/home">首页</Link>
<Link to="/product">产品</Link>
```

2. 通过使用流程反推分析
 + Link组件
  - 渲染一个a标签出来
  - 点击a标签，可以让浏览器的hash值发生对应变化
  - 在a标签内部，显示Link传入的文字内容
  ```
  import React, { Component } from 'react'

  export default class Link extends Component {
    render() {
      return (
        <a href={`#${this.props.to}`}>
          {this.props.children}
        </a>
      )
    }
  }
  ```
 + Route组件
  - 检测到浏览器地址栏hash值的变化   onhashchange事件
  - 提取地址栏hash值      window.location.hash
  - 地址栏hash路径 <---> path=""路径  对比，从而决定被显示的组件 
  - 根据hash中的路径，渲染对应的component组件
 ```
 import React, { Component } from 'react'

  export default class Route extends Component {
    constructor(){
      super()
      this.state = {
        hash:''  //存放浏览器地址栏路径
      }
    }
    componentDidMount(){
      let hash = window.location.hash.split('#')[1];  //提取浏览器地址栏中的hash路径
      this.setState({hash})
      // console.log(hash);b
      window.addEventListener('hashchange',()=>{
        console.log('浏览器哈希值发生了变化');
        let hash = window.location.hash.split('#')[1];  //提取浏览器地址栏中的hash路径
        this.setState({ hash })
      })
    }
    render() {
      let Comp = this.props.component;
      let path = this.props.path; //获取Route组件path路径参数
      return (
        <>
          {
            this.state.hash==path ? <Comp />:'' //判断浏览器中的路径是否与传过来的path相同，如果是渲染组件
          }
        </>
      )
    }
  }
 ```
 myRouter/index.js
 ```
 import Link from './Link'
  import Route from './Route'

  export {
    Link,
    Route
  }
  ```

## 手写redux
> 发布-订阅模式，写代码的套路
1. 实现的原理及核心API分析
  + let store = createStore(reducer)  //创建状态机对象
  + store.getState()  //提取状态机中的数据
  + store.dispatch(action对象) //让状态机根据action，对数据作出响应的修改
  + store.subscribe()    //订阅状态机最新的数据变化，作出响应

2. 从使用者的角度，反推核心代码实现方式

3. 最终结果参考
> myRedux/index.js
```
function createStore(render){
  let state
  function getState() {
    return state || render(state,{})
  }
  let callBacks = []
  function dispatch(action) {
    state = render(state,action)
    callBacks.forEach(cb=>{
      cb()
    })
  }
  function subscribe(callback) {
    callBacks.push(callback)
  }
  return {
    getState,
    dispatch,
    subscribe
  }
}
export {
  createStore
}
```
## 拓展内容
  + 手写vue-router
  + 手写vuex
  + 手写Promise
  + 手写Vue核心

## 前端性能优化

1. 从用户在浏览器中输入url到页面最后呈现，经历了哪些过程？
 + 用户输入了url
 + 浏览器解析url并提取域名
 + 浏览器会将域名解析为服务器ip
    - 查找本地DNS缓存列表
    - 发送请求给DNS服务器
    - www.1000phone.com ---> 23.66.78.33
 + 浏览器将端口号从url中解析出来
 + 浏览器通过ip+端口，跟目标服务器，建立TCP连接
    - 三次握手
    
 + 浏览器向服务器发送http请求报文 【6】
 + 服务器向浏览器返回http响应报文  【7】
 + 关闭连接     【8】
   - 四次挥手【断开连接的时候触发该动作】
 + 浏览器解析服务器下发的web文档
 + 如果web文档中有引用其他资源，则重复6,7

2. 性能优化的方式 
> 通过了解第一步的网页渲染流程，得出以下能够优化的地方
  + DNS
  + TCP连接时间
  + 网络请求的数量，次数尽量少发
  + 网络请求的速度，包体尽量小点
  + 缓存机制
  + 网页渲染的时间优化

3. TCP/IP协议
  + 三次握手   保证连接的稳定性与准确性
  + 四次挥手   保证在内容传输完毕后，再断开

4. 网络请求相关的优化手段
  + 雪碧图、精灵图，减少图片发起的http数量
  + 压缩合并打包，包体越小，传输越快  gzip
   - [vue通过gzip打包](https://www.cnblogs.com/yangshifu/p/9724709.html)
  + 离线缓存  localStorage

5. 雅虎军规
 [参考文章](https://www.jianshu.com/p/4cbcd202a591)


6. HTML文档的解析过程

  + 字节数据 ---> 字符串
  + 字节数据 ---> 字符串 ---> 标记token
  ```
    <span>内部文字</span>
    标记span其实位置
    标记文本内容
    编辑span的结束位置
  ```
  + 根据token，生成DOM树

7. CSS层叠样式表解析过程
  + 字节数据 ---> 字符串
  + 字节数据 ---> 字符串 ---> 标记token
  ```
    div{
      color:red;
    }
  ```
  + 根据token，生成CSSOM树

8. 浏览器的渲染原理
  + DOM树   ，DOM结构越清晰简单，解析越快
  + CSSOM树 ，选择器越清晰越简单，解析越快
  ```
    div{color:red}
    div>p>span{color:red}
  ```
  + Render树
  + 渲染并呈现给用户

9. 页面渲染的重绘与回流
  + 重绘不影响整体布局位置，比如修改了某个标签的 color
  + 回流是布局的几何属性（位置）发生了变化

10. 会导致性能问题的操作
  + 改变window大小
  + 改变字体
  + 添加或删除节点
  + 大量定位

11. 减少重绘或回流的
  + 使用transform替代 top/left
  + 使用visibility代替display:none
  + 不要使用table，小区域改动会影响整个表格

12. 重绘不一定会引发回流，回流必然引发重绘



