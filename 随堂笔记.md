## 封装组件的目的
1. 复用
2. 定制化
3. 开放封闭原则

## props参数传递
> 外部向组件内部传递数据包
1. 在组件内部，设定props

 Vue.component('组件名',{
   props:['参数名1','参数名2',...],
   template:`可以使用通过参数传递过来的数据包`
 })


2. 在调用组件的时候，使用对应的【props参数名】传递数据包

<组件名 v-bind:参数名="数据包"></组件名>

这样就可以根据HTML标签中从Vue实例化对象中拿到数据包，再传到组件中，再组件中使用Vue示例化对象的数据包，进行页面的渲染

3. 在组件内部使用props数据进行渲染

## props参数类型验证

props: {
  参数1: { //要求传递字符串
    type: 参数类型(String/Number/Boolean/Object)
    validator(val){ //验证器  val代表参数1
      return 验证条件 //只有验证条件为true时才通过
    },
    参数2:{},
    ...
  },
}
```
props: {
  str: { //要求传递字符串
    type: String
  },
  num:{
    type:Number, //数字类型
    default:100 //默认值
  },
  must:{
    type:Boolean,
    required:true  //必须要传递这个must参数
  },
  even:{ //限定用户传递偶数
    type:Number,
    validator(val){
      return val%2 == 0
    }
  }
},
```
<my-comp
  str="hello"  //没有v-bind:时传递的是字符串
  v-bind:num="200" //有v-bind:是传递的是数据/数值/布尔值
  v-bind:must="true"
  v-bind:even="4"
></my-comp>

## $emit完成子父通信

1. 在子组件my-num中，绑定事件触发子组件的事件函数childFn

2. 在子组件的childFn方法函数中，通过$emit触发自定义事件

this.$emit('自定义事件名称',需要传递的数据包)
这里的this指向这个子组件

3. 在父级空间，调用子组件的时候，绑定自定义事件，等待子级触发

<my-num @自定义事件名="父级空间事件函数"></my-num>


4. 在父级的事件函数中，修改父级的data

(1)创建子组件
(2)在子组件将事件绑定在子组件button中，点击这个子组件时触发这个函数方法
(3)在子组件的事件中通过this.$emit将创建一个自定义事件，并且传递数据，并将这个数据发送到HTML的子组件中
(4)在HTML的子组件上绑定这个自定义事件，并且在Vue实例化对象中定义一个方法来接受这个子组件的自定义事件传递过来的参数
(5)通过Vue实例化对象的函数方法接收子组件传过来的参数，通过使用这个参数改变Vue实例化对象中的数据包
总结：也就是用子组件改变父级Vue实例化对象中的数据包

```
<div id="app">
  <h1>这是父级空间的num:{{num}}</h1>
  <my-btn @btn-click="fatherFn"></my-btn>
</div>
```
```
Vue.component('my-btn',{
  template:`<button @click="childFn">修改父级的num<button>`,
  methods:{
    childFn(){
      console.log('子组件内部事件')
      this.$emit('btn-click', 10)
    }
  }
})
new Vue({
  el:'#app',
  data:{
    num:100
  },
  methods: {
    fatherFn(n){
      this.num += n
    }
  },
})
```
## bus事件总线完成非父子关系的组件通信
> var bus = new Vue()

1. 定义bus事件总线

var bus = new Vue() //bus可以换成其他名称

2. 在b-child组件中通过bus.$on(自定义事件名,回调函数(参数)) 监听
通过匹配自定义事件名称监听到通过另一个组件中的$emit传递过来的数据,并且通过回调函数的参数接收这个数据，进行后面的操作

3. 在a-child组件中通过bus.$emit(自定义事件名,数据包)
向bus事件总线发送数据

```
  var bus = new Vue()
  Vue.component('comp-a',{
    template:`<div>
                我是A组件
                <comp-a-child></comp-a-child>
              </div>`
  })
  Vue.component('comp-a-child',{
    template:`<div>
                我是A组件的孩子
                <button @click="handleSend">向B的孩子发糖</button>
              </div>`,
    methods:{
      handleSend(){
        bus.$emit('give-candys', 6)//向bus总线发送数据,并且接头暗号为give-candys
      }
    }
  })
  Vue.component('comp-b',{
    template:`<div>
                我是B组件
                <comp-b-child></comp-b-child>
              </div>`
  })
  Vue.component('comp-b-child',{
    template:`<div>
                我是B组件的孩子
                我收到{{num}}颗糖
              </div>`,
    data(){
      return {
        num:0
      }
    },
    created () { //生命周期，可以监听
      bus.$on('give-candys',(n)=>{//通过bus事件的接头暗号give-candys匹配，接收参数
        let intro = `B组件的孩子收到了${n}颗糖`
        console.log(intro)
        this.num = n //通过接收到的参数对本子组件的数据进行操作
      })
    }
  })
```

## $refs 实现组件通信
> $refs本身是用以操作DOM的，不是专门用来实现组件通信的

1. 给想要获取的DOM节点绑定ref属性
   <div ref="myDiv">div内容</div>

2. 在需要获取DOM的事件函数中通过this.$refs，获取所有绑定了ref属性的DOM节点
不管是HTML的标签还是子组件的标签都会在ref中显示，只要绑定了ref属性
console.log(this.$refs)

## 事件绑定与属性绑定的简写
1. v-bind:class  简写为  :class
2. v-on:click    简写为  @click


## 组件通信
1. 父子通信  props实现的
2. 子父通信  $emit
3. 非父子关系的组件通信   var bus = new Vue()
4. $refs获取真实DOM、组件对象  顺便完成组件通信
5. vuex 集中式状态管理器，完成组件通信 

## 三级联动案例
  + 实现三级联动
  + 一级select发生变化后，如何把二三级设为初始状态？
  通过watch监听lv1，lv1发生变化时，lv2=-1
  + 将三级联动尝试封装为一个独立组件

