## 组件通信
> props来实现
1.父子通信
> 父级向子组件传递的是数据包
> 参考components/Job 中的代码
  + 类组件
  > 通过this.props接收
  + 函数式组件
  > 通过函数的第一个形参来接收

1.1调用类组件并传递props参数
父组件:
创建数据
state = {数据}
等同于
constructor() {
    super()
    this.state = {
        数据
    }
}
```
state = {
    jobdata: [
        { jobname: '前端开发', salary: 10 },
        { jobname: '切图仔', salary: 6 },
        { jobname: '高级前端开发工程师', salary: 20 }
    ]
}
```
jobname={item.jobname}
父级传递给子级的参数名=父级的数据
```
{/* 调用类组件并传递props参数 */}
{
  this.state.jobdata.map((item,index)=>{
    // 方法1：
    // return <JobItem 
    //          jobname={item.jobname} 
    //          salary={item.salary} 
    //          key={index}
    //         />
    // 方法2：
    return <JobItem {...item} key={index}/>
    //{...item}将item中的数据逐个展开再放进去
  })
}
```
子组件接收父级传过来的数据:
this.props.父级传递给子级的参数名
```
<h3>岗位名称：{this.props.jobname}</h3>
<p>薪资待遇:{this.props.salary}k</p>
```

1.2调用函数式组件并传递props参数
父组件:
```
{/* 调用函数式组件并传递props参数 */}
<JobItemFC jobname="Java开发工程师" salary="9"/>
```
子组件:
```
export default function JobItemFC(props){ //props接收传过来的参数
  return (
    <div>
      <h3>岗位名称：{props.jobname}</h3>
      <p>薪资待遇:{props.salary}k</p>
    </div>
  )
}
```
2.子父通信
> 父级向子组件传递的是事件函数
  + 在父组件定义事件函数
  + 将父组件的事件函数，传递给子组件
  + 在子组件中，触发父组件的事件函数并携带参数

2.1在父组件定义事件函数
```
handleSalary=(idx)=>{
  console.log(idx);
  let {jobdata} = this.state;
  jobdata[idx].salary +=1 
  this.setState({
    jobdata
  })
}
```
2.2将父组件的事件函数，传递给子组件
```
{
  this.state.jobdata.map((item,index)=>{
    return <JobItem 
              {...item}
              handleSalary={this.handleSalary} //传递事件函数给子组件
              idx={index}//传递当前的index给子组件
              key={index}
            />
  })
}
```
2.3在子组件中，触发父组件的事件函数并携带参数
```
let { jobname, salary, idx } = this.props //接收父组件的参数
let { handleSalary } = this.props//接收父组件的事件函数
return (
  <div>
    <h3>岗位名称：{jobname}</h3>
    <p>薪资待遇:{salary}k</p>
    <button onClick={()=>{
      handleSalary(idx)  //触发父组件的事件函数
    }}>加薪</button>
  </div>
)
```

## 获取真实DOM
> 不要滥用真实DOM操作
> createRef
> 参考components/RefDemo 示例代码

【1】定义获取DOM的属性对象
ref名 = React.createRef()
或引入
import React, { createRef } from 'react'
直接使用createRef方法
ref名 = createRef()

【2】将属性通过ref绑定给某个dom元素
<div ref={this.ref名}></div>

【3】提取DOM节点的属性
函数(){
  this.ref名.current.属性
}


## Form表单元素的操作方式
1.非受控组件的方式操作
> 通过ref操作input

```
myInput = React.createRef() //【1】定义获取DOM的属性对象
```
```
{/* 【2】将属性通过ref绑定给某个dom元素 */}
<input 
  type="text" 
  ref={this.myInput} 
  onKeyUp={this.handleInput}
/>
```

2.通过受控组件的方式操作
> value + onChange来操作input
> 参考components/ControlDemo

```
state = {
    msglist:[
      '你好',
      '在吗？'
    ],
    msg:'input默认数据' //【1】定义input同步展示的数据
  }
```
```
{/* 【2】通过value展示msg */}
<input 
  type="text" 
  value={this.state.msg} 
  onChange={this.handleChange}
  onKeyUp={this.handleInput}
/>
```
```
handleChange=(e)=>{ //【3】只负责修改msg，从而引发input显示变化
  this.setState({
    msg:e.target.value
  })
}
handleInput = (e)=>{ //【4】提取最新的msg，等同于提取最新的input内容，进行使用
  console.log(e);
  if(ev.keyCode===13){
    let {msg,msglist} = this.state;
    this.setState({
      msglist:[
        ...msglist,  //展开旧数据包内容
        msg   //新数据内容
      ],
      msg:''   //清空input显示的value值
    })

  }
}
```

## 生命周期函数
> 类组件独有的能力
[生命周期函数图](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)
1. 初始化
  + constructor
  + render
  + componentDidMount  在这个生命周期函数中，进行初始化数据包加载

2. 更新阶段
  + render
  + componentDidUpdate

3. 销毁阶段
  + componentWillUnmount

## 在React中使用axios
> 跟在vue中的使用流程一样
```
npm install axios
import axios from 'axios'
axios.get(url).then(res=>{})
```
## Hooks新特性
> 16.3后续的版本才有   
> 可以让我们在函数式组件内部做动态交互 state 跟 生命周期的效果
1. useState
> 让函数式组件内部拥有响应式state数据
> 参考components/HooksDemo/StateDemo
引入useState,useEffect方法
```
import React, { useState,useEffect } from 'react'
```
let [数据,赋值数据的方法] = useState(初始化数据)

return (
  //调用参数
  {数据}
)

```
<button onClick={() => {
  setNum(num + 1)
}}>
  按钮{num}
</button>
```

2. useEffect
> 默认情况下，只要视图发生更新就会触发执行，
> 可以通过调整useEffect第二个参数来模拟不同生命周期函数的执行时机
> 参考components/HooksDemo/EffectDemo

useEffect(()=>{ //模拟componentDidUpdate效果
    //代码
},[数据])//监听数据,数据更新时再次执行useEffect

```
let [num,setNum] = useState(233)
  useEffect(()=>{ //模拟componentDidUpdate效果
    console.log('组件更新了num',num);
  },[num])
```
[]中不写任何数据---不监听，只执行一次
```
useEffect(() => { //模拟componentDidMount效果
  let url = 'https://shopapi.smartisan.com/product/home'
  axios.get(url).then(res => {
    console.log(res);
    setBanner(res.data.data.home_carousel)
  })
}, [])
```