## 前端安全相关

## XSS攻击 (Cross-Site Scripting)
> 跨站脚本攻击
> 什么是XSS攻击？如何防范XSS攻击？
攻击者通过各种手段将可执行代码注入到网页中（项目中）

两大类型：持久型、非持久型

1. 持久型
> 用户通过项目开放的一些功能，将一段非法代码注入到了数据库
例如：在评论区提交一段恶意的脚本代码，会被存储至数据库
+ 所有加载了评论列表的用户都会受到攻击

2. 非持久型
> 通过url访问网页的时候，在url后缀了恶意代码
```
https://www.douban.com?name=%3Cscript%3Ealert(1)%3C/script%3E
```
Chrome浏览器默认能够防御这种攻击

3. 防御策略
+ 转义字符
> 对于用户的输入，应该永远不信任它，普遍的方案，就是对输入内容进行转义操作
> 引号、尖括号、斜杠
```
function escape(str){
  str = str.replace(/</g,'>')
  str = str.replace(/>/g,'>')
  str = str.replace(/"/g,'"')
  return str
}

escape(用户提交的字符串)
```
+ xss第三方模块进行处理
[xss模块文档](https://www.npmjs.com/package/xss)
```
var xss = require("xss");
var html = xss('<script>alert("xss");</script>');
console.log(html);
```

+ CSP
> 本质就是建立白名单，开发者通过某种手段，告知浏览器哪些外部资源是可执行的
> HTTP header中 设置 Content-Security-Policy
```
Content-Security-Policy:default-src 'self'  //只允许加载本站资源
Content-Security-Policy:img-src https://*  //只允许https协议的图片路径
```

## CSRF (Cross-Site request forgery)
> 跨站请求伪造
攻击者诱导受害者进入一个他不知情的第三方网站，
在第三方网站中，
利用受害者的已经获取的权限凭据，
向被攻击的网站发送跨站请求

+ 典型的CSRF攻击流程：A受害者  B攻击者
1. 受害者登录A网站，并在浏览器中记录了登录凭据（cookie、token）
2. 攻击者在A网站，注入了一个非常有吸引力的内容，诱导用户进入B站点
3. 站点B向站点A发起请求，携带受害者的凭证
4. A误认为本次请求是正常请求
5. A站点就向B站点所请求的目标账户，转账1个亿
6. 攻击完成，受害者在不知情的情况下，损失一个亿

+ 如何防御
> 从如下几个方法，配合使用，可以有效防御
1. 添加验证码
> 太过频繁，会影响用户体验，一般在非常敏感的操作功能下，才会添加验证
> 转账、交易
  + 手机验证码
  + 图片验证码
  + 2+1=？  验证

2. 使用token
> 服务端签发的，加密字符串 asdfasdfasdfasdf4646546asdfasdf
  + 服务端给用户生成下发一个token，加密后传给用户
  + 用户请求服务器时，需要此token
  + 服务端验证token是否合法

3. 判断请求来源
> 在Header中携带一个Referer信息，描述当前请求的来源
```
Referer: https://www.douban.com
```

4. Samesite Cookie属性
> 从浏览器发请求的源头，限制跨站携带cookie
拒绝B站点，携带非法获取的cookie凭据，访问A站点
```
SameSite=Strict
```

## 点击劫持
点击劫持在web中隐藏一个透明的 iframe,
诱导用户点击,
用户以为点击的是他看到的东西，
实际上点到了iframe,执行了用户不知情的操作

典型的攻击流程  A被攻击   B攻击者
1. 攻击者构建了一个比较有吸引力的网站B
2. 将被攻击的页面A放置在当前页面的iframe中
3. 使用样式让iframe区域，比较有吸引力
4. 你以为点击的B站点的某个区域，实际点击了A站点

防御策略

1. X-frame-options响应头
> 可以通过这个方式限制用户通过iframe访问A站点
> 这个响应头，在一些低版本的浏览器中，支持度不是很好
```
X-frame-options:deny   //A网站页面不允许通过iframe加载显示
X-frame-options:sameorigin   //A网站同域名下的网页，可以通过iframe加载显示
X-frame-options:allow-from   //A网站页面可以在指定来源的iframe加载显示
```

2. JS防御
> 如果上面的方式，浏览器无法支持，可以通过js控制的方式来防御
有可能会被攻击的A站点：
```
<head>
  <style id="box">
    html{
      display:none !important;
    }
  </style>

  <script>
    let self = A站点域名;
    let other = 发起iframe访问的站点域名;
    if(self==other){ //如果是非法的用户访问了网页，直接隐藏所有内容
      document.getElementById('box').remove()
    }
  </script>
</head>
```

## 中间人攻击
正常访问：
用户浏览器----A网站服务器
被中间人攻击后的访问：
用户浏览器----中间人服务器B----A网站服务器

HTTPS安全证书验证
 + 浏览器发起https请求
 + 服务器返回https证书
 + 客户端验证证书是否合法，如果不合法提示警告

数据传输阶段
  + 当证书验证通过后，本地生成随机数
  + 通过公钥加密随机数，并把加密后的随机数传给服务器
  + 服务器通过私钥对随机数进行解密
  + 服务器通过客户端传入的随机数构造对称加密算法，对返回结果内容加密后传输

防御策略
  + 浏览器做证书有效性验证
  + 证书颁发者可信度检测
  + 签名检测
  + 站点身份检测


## 安全相关知识的作用
1. 有安全意识，可以避免一些低级安全问题
2. 服务端开发对安全性的要求比较高的
3. 安全相关内容，可以为面试加分

## 后续内容
1. 网页重构
2. 原生JS开发面试题
3. ES6常用新语法
4. Vue、React、小程序wx:if  this.setData
5. 手写react-router-dom、redux

## 技术面试官问问题的套路
> 盯住一个角度，逐层递进提问，直到触及面试者的极限
> 面试是交流
1. redux是否有使用？  用过
> 在什么项目中的什么场景下使用了redux
> 这个场景使用redux的必要性、好处
> redux + react-redux + redux-thunk

2. connect(mapStateToProps,mapDispatchToProp)(组件)
> mapStateToProps具体作用
> mapDispatchToProp的格式以及具体作用

3. redux背后实现的原理？











